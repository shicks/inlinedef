% \iffalse
%
% inlinedef.dtx
% Copyright 2008 Stephen D. Hicks
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Stephen D. Hicks
%
% This work consists of the files
%   README
%   inlinedef.dtx (this file)
%   inlinedef.ins
%   inlinedef.pdf
% and the derived files
%   inlinedef.sty
%   inlinetest.tex
%
% Run LaTeX on this file to produce documentation.
% Run LaTeX on the .ins file to produce the package.
%<*driver>
\ProvidesFile{inlinedef.dtx}
\documentclass{ltxdoc}
\CheckSum{1876}
%\OnlyDescription % (un)comment this line to show (hide) source code
\RecordChanges
\EnableCrossrefs
\CodelineIndex   % (un)comment this line to index source by page (line)
\begin{document}
  \newcommand*{\Lopt}[1]{\textsf {#1}}
  \parindent0pt
  \def\*#1{\texttt{\string#1}} %% sdh - |...| doesn't work in headings
  \makeatletter
  %
  \newcount\mac@depth\mac@depth\z@
  \newcommand\@macros{}\newcommand\@endmacros{}
  \catcode`&3  %% we use a funny catcode to ensure never used.
  \def\@macros#1,{\macro{#1}\global\advance\mac@depth\@ne\relax
    \@ifnextchar&\@gobble\@macros}
  \def\@endmacros{\let\mac@next\relax\ifnum\mac@depth>\z@
    \endmacro\let\mac@next\@endmacros
    \global\advance\mac@depth\m@ne\fi\mac@next}
  \newenvironment{macros}[1]{\@macros#1,&}{\@endmacros}
  \newenvironment{params}{\par Parameters:\catcode`*13\def*{\\\qquad}}{}
  \catcode`&4  %% put it back
  % Stop indexing at a certain point
  \newcommand\StopIndexing{\let\special@index\@gobble}
  % done...
  \makeatother %% must be balanced for character table to work properly
  %
  % Don't index unimportant names...
  \DoNotIndex{\@ne,\@whilesw,\@gobble,\@eha,\@ehd,\@empty,\@xa}
  \DoNotIndex{\advance,\begin,\begingroup,\xdef}
  \DoNotIndex{\catcode,\DeclareRobustCommand,\def,\detokenize,\edef}
  \DoNotIndex{\end,\endgroup,\errorcontextlines,\expandafter,\foo}
  \DoNotIndex{\futurelet,\gdef,\global,\let,\long}
  \DoNotIndex{\m@ne,\makeatletter,\makeatother,\meaning,\message}
  \DoNotIndex{\MessageBreak,\newcommand,\newcount,\newif,\newtoks}
  \DoNotIndex{\noexpand,\outer,\PackageError,\protect,\protected@edef}
  \DoNotIndex{\relax,\renewcommand,\space,\string,\the\toks,\undefined}
  \DoNotIndex{\ifcat,\ifnum,\ifx,\else,\fi,\fi,\fi}
  % Do the stuff
  \DocInput{inlinedef.dtx}
  \setcounter{IndexColumns}{2}
  \def\bang{\texttt{!}}
  \PrintIndex
  %\PrintChanges
\end{document}
%</driver>
% \fi
% \changes{v1.0}{2008/07/05}
%       {(SDH) Initial version.}
%
% \GetFileInfo{inlinedef.dtx}
% \title{The \textsf{inlinedef}%
%   \iffalse - don't include this for now...
%   \thanks{\textsf{darcs} repository at
%   \texttt{http://www.physics.cornell.edu/$\sim$shicks/darcs/latex/inlinedef/}.
%   Patch submissions welcome.}\fi
%   package}
% \author{Stephen Hicks\thanks{email: \texttt{sdh33@cornell.edu}}}
% \date{\fileversion{} -- \filedate}
% \maketitle
%
% \section{Usage}
%
% \subsection{The problem}
% Often package writers want to redefine certain macros to do slightly
% more than what they did previously, adding a control sequence or two
% to the beginning or the end of the definition.  The easiest way to
% accomplish this is to use something like
% \begin{verbatim}
%   \let\old@macro\macro
%   \def\macro{...\old@macro...}\end{verbatim}
% But this sort of construction can cause problems if another package
% also wants to redefine the same macro and happens to choose the same
% name to save it to.  It's also an ugly solution in that it pollutes
% the global namespace with extra macro names.  A much cleaner solution
% is to define the new macro with the old macro expanded inline, as in
% |\edef\macro{...\macro...}|.  This is generally problemmatic because
% there are often undefined control sequences and macros that we don't
% want to expand quite yet.  A compromise is to use |\expandafter|, but
% this leads to error-prone and unreadable code:
% \begin{verbatim}
%   \expandafter\def\expandafter\macro\expandafter{\expandafter
%     ...\macro...}\end{verbatim}
%
% \subsection{The solution}
% What we really want is a way to expand just a few
% tokens in the definition and leave the rest untouched.  
% \iffalse - not ready yet...
% The package |expansions| provides a way to do this more
% generally, but in the case of definitions, this package is more
% expressive and simpler.
% \fi
% We provide a command \DescribeMacro\Inline|\Inline| 
% that can be inserted before a |\def| or |\gdef| (optionally prefixed
% by |\long|, |\outer|, and/or |\global|, as in
% |\Inline\long\outer\gdef...|).  Within |\Inline| definitions,
% only tokens preceded by \DescribeMacro\Expand|\Expand| are expanded.
% Thus, the previous example becomes
% \begin{verbatim}
%   \Inline\def\macro{...\Expand\macro...}\end{verbatim}


 %%%%% TODO - comment about performance, recommend
 %%%%% \LaTeX2\epsilon's |\unexpanded| instead.



%
% \subsection{Special commands}
% While nearly everything can be done with |\Expand| alone, we provide
% a few more keywords for completeness and convenience.
% \begin{itemize}
%   \item\DescribeMacro\Expand|\Expand| - Performs a single expansion
%     on the token or group
%     immediately following and places the result directly into the
%     definition without further processing.  In the case of a group,
%     only the first token is expanded (although |\expandafter|s may
%     be used to expand a different token), and
%     the outermost grouping braces are discarded.
%   \item\DescribeMacro\MultiExpand|\MultiExpand|\marg{number} -
%     Expands the following token or group the given number of times.
%     For example,
%     \begin{verbatim}
%   \MultiExpand{3}{\expandafter\expandafter\expandafter\a
%     \expandafter\b\c}\end{verbatim}
%     expands first |\c|, then |\b|, then |\a|, and inserts the whole
%     expansion into the definition with no braces.  Note that the braces
%     are important.  Otherwise it will just try to expand the first
%     |\expandafter| three times, which is clearly wrong.
%   \item\DescribeMacro\UnsafeExpand|\UnsafeExpand| - This version simply
%     inserts an |\expandafter|, performing the expansion as in |\Expand|
%     above, but reinserting the result back
%     into the stream to be processed.  Thus, any tokens like |\Expand| or
%     |\Super| in the expansion will be acted on.  Unlike the previous two
%     commands, groups are \emph{not\/} treated differently.
%   \item\DescribeMacro\NoExpand|\NoExpand| - If a token is preceeded
%     by |\NoExpand| then it is inserted in the definition exactly as-is.
%     This is required to insert any of the special tokens |\Expand|,
%     |\NoExpand|, etc, as well as the internal token |\ID@END|, into a
%     definition.  If the token immediately following |\NoExpand| is
%     an open-brace then the entire text of the group will be inserted
%     without expansion, and the outer level of grouping will be lost.
%   \item\DescribeMacro\Super|\Super| - When redefining an already
%     existing macro, |\Super| will expand to the previous definition of
%     the macro.  Any macro parameters are automatically substituted.
%     If the macro is undefined, or if the new parameter text doesn't match
%     with the old text, then this will cause an error.
%   \item\DescribeMacro\Recurse|\Recurse| - This is complementary to
%     |\Super| and, while not strictly necessary, is included for clarity.
%     |\Recurse| is equivalent to
%     |\NoExpand\macro| when defining |\macro|.  However, since |\macro|
%     is, by default, not expanded anyway, this is a bit redundant.
% \end{itemize}
%
% \goodbreak
% \subsection{Calling options}
% When the name of the macro we're defining is encountered, there are
% three different ways we might proceed: leave it alone (|\NoExpand|),
% expand it with implicit parameters (|\Super|), or expand it with
% explicit parameters (|\UnsafeExpand|).
% We therefore allow zero, one, or two stars to come after |\Inline| to
% change this behavior.
% \begin{itemize}
%   \item\DescribeMacro\Inline|\Inline| - Without any stars, we default
%     to leaving the macro name alone, as in |\NoExpand\macro|.
%     This is the most consistent behavior with the rest of the package and
%     works regardless of whether the macro is being defined or redefined.
%   \item\DescribeMacro{\Inline*}|\Inline*| - With a single star, we treat
%     the macro name as a
%     call to |\Super| and expand it with parameters inserted automatically.
%     This is preferred over |\Expand| because it doesn't lead to the possible
%     surprises in the case of recursively-defined macros.
%   \item\DescribeMacro{\Inline**}|\Inline**| - Finally, with two stars,
%     the macro name is treated as if it were preceeded by |\UnsafeExpand|.
%     Any parameters must be inserted explicitly, and the expansion is
%     itself subject to inline processing.  Note that this form is the most
%     dangerous.
% \end{itemize}
%
% \index{Inline\bang=\verb!*+\Inline+\bang|usage}
% \begingroup\def\index#1{}%\iffalse - index by hand! - \fi
% \DescribeMacro{\Inline!}\endgroup
% One final option applies only in the case of redefining an already-existing
% macro.  In this case, if the parameter text of the new definition differs
% from the parameter text of the old definition, we will produce an error.
% This error can be suppressed by adding a bang to the end of |\Inline|
% (either before or after the stars), acknowledging that any ill consequences
% that result are your own fault.
%
% \iffalse - this part not yet implemented!
% The last special
% token is \DescribeMacro\Args|\Args|.  |\Args| inserts a protected
% version of the argument text, that can be used when recursing, as
% in |\Recurse\Args|, to make the exact same call again.  Otherwise,
% when using |\Recurse|, you are responsible for passing the arguments
% yourself, unlike |\Super|, which behaves like a hypothetical
% |\ExpandAfter\ExpandAfter\ExpandAfter\Expand\ExpandAfter\Recurse\Args|
% (though |\ExpandAfter| doesn't currently
% exist).
% \fi
%
% \subsection{Known issues}
% \begin{itemize}
%   \item If a macro is defined with a character other than |#| catcoded to
%     6, then |\Super| will fail unless the same character is used in the
%     redefinition.
% \end{itemize}
%
% \subsection{Related packages}
% \begin{description}
%   \item[moredefs] The \textsf{moredefs} package in the \textsf{frankenstein}
%     collection provides some similar syntactic sugar, but is not as
%     expressive.
% \end{description}
%
% \StopEventually{}
%
% \filbreak
% \makeatletter
% \section{Implementation}
% We start with the identity.  This package expects \LaTeX2e.
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{inlinedef}%
           [2016/05/07 v1.1 Inlined expansions within definitions]
% \begin{macro}{\@xa}
% Make the |@|-sign into a letter for use in macro names.  As long as the
% packages are well-behaved, we can put this here and not later.  We also
% define |\@xa| to be |\expandafter| for convenience.
%    \begin{macrocode}
\makeatletter
\let\@xa\expandafter
%    \end{macrocode}
% \end{macro}


%
% \begin{macros}{\ifID@aborted,\ifID@star,\ifID@starstar,\ifID@bang}
% We define a conditional so that we can gracefully abort in case of an error.
%    \begin{macrocode}
\newif\ifID@aborted
\newif\ifID@star
\newif\ifID@starstar
\newif\ifID@bang
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@toks,\ID@count}
% At some point we need to stop using the internal toks registers and allocate
% our own, because somebody might want to |\Expand{\the\toks@}| and expect
% something else.  We can get by with a single one though by defining a
% |\ID@pdef| that doubles all the |#| signs and then does a regular def, so that
% |\ID@pdef\cs\ID@toks ... \cs| will be the same as |\the\ID@toks|.
%    \begin{macrocode}
\newtoks\ID@toks
\newcount\ID@count
%    \end{macrocode}
% \end{macros}
%
% \begin{macro}{\ID@quarks}
% We use a simple macro to gather the list of ``quarks'', which are
% tokens that expand to themselves.  These are used for the ``specials''
% that can be used in |\Inline| definitions' bodies to break out into
% custom expansion behavior.  This macro is simply a series of
% |\def\foo{\foo}| statements, and is executed in a local group
% for every call to |\Inline|.
%    \begin{macrocode}
\def\ID@quarks{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macros}{\Inline,\ID@scandef}
% These are the macros that get it all started.  |\Inline| opens up
% a group (which is closed at the end of |\ID@define|) and initializes a
% toks register (we don't bother allocating it since we're in a group
% and don't call any \LaTeX{} or \TeX{} macros that make use of allocated
% toks registers.  Then we scan the tokens until we
% find either an |\edef| or an |\xdef|.  If it's anything else, we just
% add it to the toks register.  We also have a list of bad tokens that
% will cause an error message, so that we don't go too far before figuring
% out what went wrong.  Should |\Inline| be |\outer|?
%    \begin{macrocode}
\newcommand\Inline{%
  \begingroup
  \@testtrue\ID@starfalse\ID@starstarfalse\ID@bangfalse
  \ID@inlinedef@initialize
}

\def\ID@inlinedef@initialize#1{%
  % (a) group
  \ifcase\ID@is@group{#1}\ID@then
    \PackageError{inlinedef}{%
        Groups are not allowed immediately after \protect\Inline}\@ehd
    \ID@abort
  \fi
  % (b) star
  \if#1*%
    \ifID@starstar
      \PackageError{inlinedef}{\protect\Inline*** is illegal}\@ehd
      \@xa\ID@then\@xa\ID@abort
    \fi
    \ifID@star
      \ID@starstartrue
    \else
      \ID@startrue
    \fi
    \ID@then\ID@inlinedef@initialize
  \fi
  % (c) bang
  \if#1!%
    \ifID@bang
      \PackageError{inlinedef}{\protected\Inline!! is illegal}\@ehd
      \@xa\ID@then\@xa\ID@abort
    \fi
    \ID@bangtrue
    \ID@then\ID@inlinedef@initialize
  \fi
  % (d) default
  \iftrue\ID@then
    \ID@makedef\ID@inlinedef@start#1%
  \fi
  \ID@esac
}

\def\ID@inlinedef@start#1#2#3#4{%
%    \end{macrocode}
% We start by opening a group, defining all the ``quarks'', clearing
% the token register, and then looking 
  \begingroup\ID@quarks\ID@toks{}%
}
%    \end{macrocode}
% Here is where the ``main loop'' is initiated.  We start by
% pretending to allocate another token register (though we actually
% just |\toksdef| it), and then define a number of quarks which we
% use as delimiters for various purposes.  Finally, we start scanning.
% Afterwards, we test if there was an error and if not, we expand the
% definition command \emph{after} the |\endgroup| so that we can clean
% up all the local variables.
%    \begin{macrocode}
  % Other definitions
  \global\ID@abortedfalse
  \let\ID@super#2%
  % If \ID@super is undefined/relax, make it a quark instead to prevent matching
  \ifx\ID@super\ID@UNDEFINED\def\ID@super{\ID@super}\fi
  \ifx\ID@super\relax\def\ID@super{\ID@super}\fi
  \def\@macroname{#1}% for error message
  \ID@fixparams#3\ID@END
  % These are used by \Super but easier to define here
  \def\@reservedb#3{}%
  \edef\@reservedb{\@xa\ID@getprefix\meaning\@reservedb\ID@END}%
  \ifx#2\ID@UNDEFINED
    \let\@reserveda\undefined

    %%% TODO - make getprefix more permissive

  \else
    \edef\@reserveda{\@xa\ID@getprefix\meaning#1\ID@END}%
  \fi
  % Scan it all into \ID@toks
  \ifID@bang\else\ID@checkusage\fi
  \ifID@aborted\else
    \ID@scan#4\ID@END{}% we need the {} so that the the #1# works...
  \fi
  %
  \ifID@aborted
    \def\command{}% gracefully ignore
  \else
    \let#2\relax % don't want it expanded in the |\edef| below
    \edef\command{#1#2#3{\the\ID@toks}}%
  \fi
  %
  \global\ID@toks\@xa{\ID@fixedparams}% just to test...
  \expandafter\endgroup\command
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@newset,\ID@newset@eat}
% We define a very primitive concept of a ``set'', which allows $O(1)$
% evaluation of whether a given token is an element.  The design for
% this is modeled off of |\newif|: sets are control sequences that
% begin with |\is...| and provide a ``setter'' that begins with |\set...|.
% For instsance:
% \begin{verbatim}
%   \ID@newset\isfoo
%   \setfoo\bar
%   \setfoo\baz
%   \if\isfoo\bar\message{bar is foo}\fi
%   \if\isfoo\qux\else\message{qux is not foo}\fi\end{verbatim}
%    \begin{macrocode}
\def\ID@newset#1{%
 %  --- note: use ifcsname to prevent leakage
  \def#1##1{%
    0\@xa\ifx\csname ID@set@\string#1\string##1\endcsname\@xa0\else1\fi}%
  \@xa\def\csname set\@xa\ID@newset@eat\string#1\endcsname##1{%
    \@xa\let\csname ID@set@\string#1\string##1\endcsname\@xa}%
}
\def\ID@newset@eat#1is{}
%    \end{macrocode}
% \end{macros}



% \begin{macros}{\ID@empty,\ID@nonempty}
% We want a fully-expandable way to determine if an argument is
% empty, so we use a trick from Donald Arsineau's url.sty.  We use
% a funny catcode that should never actually show up anywhere
% (so this will break on anything with an X$_3$).
%    \begin{macrocode}
{
  \catcode`X=3
  \long\gdef\ID@nonempty@#1#2X#3#4#5XX{#4}
  \gdef\ID@empty[3]{\ID@nonempty@#1XX{#3}#2XX}
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@is@empty,\ID@is@group}
% We also define wrappers that can be used with |\ifcase|, for
% both ``is empty'' and ``is a group'' (anything other than a
% single token; note that we can't actually distinguish a group
% with a single token from a bare token in this case).
%    \begin{macrocode}
\newcommand\ID@is@empty[1]{\ID@empty{#1}01}
\newcommand\ID@is@group[1]{\@xa\ID@empty{\@gobble#1}{\ID@empty{#1}01}0}
%    \end{macrocode}
% \end{macros}




%
% \begin{macros}{\isID@def,\isID@baddef}
% We define a set of ``define'' tokens, which we look for during
% the first phase of making a definition.  We also define a blacklist
% of define tokens that we refuse to use.
%    \begin{macrocode}
\ID@newset\isID@def
\setID@def\def
\setID@def\gdef
\setID@def\newcommand
\setID@def\renewcommand
\setID@def\providecommand

\ID@newset\isID@baddef
\setID@baddef\edef
\setID@baddef\xdef
\setID@baddef\let
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@then,\ID@esac}
% Here we set up a simple fully-expandable ``switch'' construct.
% We will end a number of macro definitions with
% \begin{verbatim}
%   \iffoo  ... \ID@then ... \fi
%   \ifbar  ... \ID@then ... \fi
%   \iftrue\ID@then ... \fi
%   \ID@esac
% \end{verbatim}
% This ensures that everything after the |\ID@then| ends up
% \emph{after} the |\ID@esac|.  This is a nicer alternative to
% earlier versions that continually redefined a |\next| macro.
% Note that there \emph{must not} be any bare |\fi|s between
% the |\ID@then| and the delimiting |\fi|: if an extra condition
% is needed, it should be protected by a group.
%    \begin{macrocode}
\@xa\def\@xa\ID@then\@xa#1\csname fi\endcsname#2\ID@esac{%
  \csname fi\endcsname
  #1%
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macro}{\ID@makedef}
% We define a number of ``define prefixes'', such as |\Inline| and
% |\InlineSpecial|, and this functionality is factored out into
% |\ID@makedef|.  It reads tokens looking for one of |\def|, |\gdef|,
% |\newcommand|, |\renewcommand|, or |\providecommand|.  In the case
% of the latter three, it looks for a following |*|, and for the
% former, allows additional prefixes like |\global|, |\long|, or
% |\outer|.  It then provides four arguments (the define command,
% the macro name, the parameter list, and the definition block)
% to the provided macro (the |#1| argument to |\ID@makedef|).
%    \begin{macrocode}
\def\ID@makedef#1{%
  \begingroup
    \ID@makedef@finddef{#1}{}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ID@makedef@finddef}
% The first stage of scanning a definition is to find the actual
% definition token, e.g. |\def| or |\newcommand|.  Any groups
% we find before encountering the definition command are
% discarded (and will be an error if they contain other than
% a single token).  We do a minimal amount of error checking:
% (a) if we encounter a group, then something's gone wrong,
% so try to recover; (b) if we see a good definition token,
% then move on to the next step, |\ID@makedef@findcs|; (c)
% if we see a blacklisted definition token then bail out;
% (d) any other token is added to the list and we repeat.
% \begin{params}
%  * |#1| is the handler passed to |\ID@makedef|
%  * |#2| is the tokens we've scanned so far
%  * |#3| is the current token being scanned
% \end{params
%    \begin{macrocode}
\def\ID@makedef@finddef#1#2#3{%
  % (a) group
  \ifcase\ID@is@group{#3}\ID@then
    \PackageError{inlinedef}{No \protect\def-like token found.}\@ehd
    \ID@abort
  \fi
  % (b) definition
  \if\isID@def#3\ID@then
    \ID@makedef@findcs{#1}{#2#3}%
  \fi
  % (c) blacklisted definition
  \if\isID@baddef#3\ID@then
    \PackageError{inlinedef}{Cannot use fully-expanding defines.}\@ehd
    \ID@abort
  \fi
  % (d) default
  \iftrue\ID@then
    \ID@makedef@finddef{#1}{#2#3}%
  \fi
  \ID@esac
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ID@makedef@findcs}
% The second stage in scanning a definition is to find the
% control sequence being defined.  This is very similar to
% |\ID@makedef@finddef| in that (a) we expect non-groups.
% We also handle a few special cases: (b) a |*| that should
% be added onto the definition tokens (e.g. for |\newcommand|),
% and (c) |\csname| which we expand immediately, since it's
% more useful than trying to support overriding the definition
% of |\csname| with whatever we're defining.  Otherwise
% (d) we continue on to |\ID@makedef@findargs|.
% \begin{params}
%  * |#1| is the handler passed to |\ID@makedef|
%  * |#2| is the definition command tokens
%  * |#3| is the current token being scanned
% \end{params
%    \begin{macrocode}
\def\ID@makedef@findcs#1#2#3{%
  % (a) group
  \ifcase\ID@is@group{#3}\ID@then
    \PackageError{inlinedef}{Cannot define more than a single token: #3}\@ehd
    \ID@abort
  \fi
  % (b) star
  \if#3*\ID@then
    \ID@makedef@findcs{#1}{#2#3}%
  \fi
  % (c) \csname
  \ifx#3\csname\ID@then
    \begingroup
      \def\@temp{\ID@makedef@findcs{#1}{#2}}%
      % 1st \@xa expands the \csname, 2nd \@xa expands \@temp before \endgroup
      \@xa\@xa\@xa
    \endgroup
    \@xa\@temp\csname % replace the \csname we ate as #3
  \fi
  % (d) default case
  \iftrue\IF@then
    \ID@makedef@findargs{#1}{#2}{#3}%
  \fi
  \ID@esac
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ID@makedef@findargs}
% Once we have the control sequence being defined we just need to scoop
% up any arguments, up until the open-brace.  We use a brace-delimited
% parameter |#4| for this, adn then pass the result directly to the
% handler (|#1|) to process.  This is actually a very simple macro.
%    \begin{macrocode}
\def\ID@makedef@findargs#1#2#3#4#{%
  #1{#2}{#3}{#4}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\InlineSpecial,\ID@inlinespecial}
% We define the |\InlineSpecial| user-facing command in terms of
% |\ID@makedef| and |\ID@inlinespecial|.
%    \begin{macrocode}
\newcommand\InlineSpecial{\ID@makedef\ID@inlinespecial}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ID@inlinespecial}
% The |\ID@inlinespecial| macro does the actual work of defining
% a special.  It takes the control sequence |#2| that the user
% specified and defines a macro with a different, derived name
% (|\csname ID@special@\string#2\endcsname|).  We also add |#2|
% to the list of specials, so that they can be set up as quarks
% when an |\Inline| definition is started.
% \begin{params}
%  * |#1| is the definition tokens (e.g. |\long\def|)
%  * |#2| is the control sequence
%  * |#3| is the argument tokens (e.g. |#1#2| or |[2]| for |\newcommand|)
%  * |#4| is the actual definition
% \end{params}
%    \begin{macrocode}
\long\def\ID@inlinespecial#1#2#3#4{%
  \def\@temp{#1}% save in a macro so we can jump over it with \@xa
  \@xa\@temp\csname ID@special@\string#2\endcsname#3{\begingroup#4\ID@END}%
  \@xa\def\@xa\ID@quarks\@xa{\ID@quarks\def#2{#2}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Expand}
% Here we define the |\Expand| special.  It's actually
% a pretty simple definition, once we've defined all the
% infrastructure.  We expand the parameter exactly once
% (note that if it was a group, we will lose the grouping
% braces) and then pass it along to |\Save| to store in
% |\ID@toks|.
%    \begin{macrocode}
\InlineSpecial\newcommand\Expand[1]{\@xa\Save\@xa{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NoExpand}
% The |\NoExpand| special is even simpler.  Its entire
% purpose is to ensure that a ``special'' token is not
% actually treated as a special but is instead saved
% directly, without expansion.
%    \begin{macrocode}
\InlineSpecial\newcommand*\NoExpand[1]{\Save{#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macros}{\ExpandMulti}
% The |\ExpandMulti| special simply recurses until
% its first argument goes to zero.
% \begin{params}
%  * |#1| is the number of times yet to expand
%  * |#2| is the tokens to expand
% \end{params}
%    \begin{macrocode}
\InlineSpecial\newcommand\ExpandMulti[2]{%
  \ifnum#1=\z@\ID@then
    #2%
  \fi
  \iftrue\ID@then
    \count@#1\relax
    \advance\count@\m@ne
    % 1st \@xa expands #2 once, 2nd \@xa expands \the\count@
    \@xa\@xa\@xa\Continue
    \@xa\@xa\@xa{%
      \@xa\@xa\@xa\ExpandMulti
      \@xa\@xa\@xa{\@xa\the\@xa\count@\@xa}\@xa{#2}}%
  \fi
  \ID@esac
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ExpandFully}
% Performing a full expansion simply involves passing a subset
% of the definition to |\edef| and replacing the output.
%    \begin{macrocode}
\InlineSpecial\newcommand\ExpandFully[1]{%
  \edef\@temp{#1}\@xa\Save\@xa{\@temp}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ExpandUnsafe}
% Unsafe expansion is even easier.  We just insert an |\@xa|
% into the token stream, without consuming anything.
%    \begin{macrocode}
\InlineSpecial\newcommand\ExpandUnsafe{\@xa}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Super}
% The |\Super| special is a little more complicated, and only
% works if the macro we're defining was already defined.  We
% start by checking these preconditions, and then we expand
% the stored previous definition.  We also implicitly include
% the same parameters, though potentially we shouldn't?
% Finally, because of the possibility for infinite loops, we
% need to make sure to check the |ID@aborted| flag and bail
% out if there's been a problem.
%    \begin{macrocode}
\InlineSpecial\newcommand\Super{%
  \ID@checkusage\ID@checkredef{Super}%
  \ifID@aborted\else
    \@xa\@xa\@xa\Save\@xa\@xa\@xa{\@xa\ID@super\ID@fixedparams}%
}
%    \end{macrocode}
% \end{macro}






% \begin{macro}{\ID@abort}
% In case the error was just the wrong type of |\def|, we consume up to and
% including the first explicit group.
%    \begin{macrocode}
\newcommand\ID@abort{}\def\ID@abort#1#{\endgroup\@gobble}
%    \end{macrocode}
% \end{macro}
%
% \begin{macros}{\ID@fixparams,\ID@fixparams@start}
% In order for |\Super| to work properly, we need to fix the parameter
% list to put the |#1| in braces, since it actually consists of two tokens.
% Therefore, |\ID@fixparams| takes everything between it and |\ID@END|
% and puts it in |\ID@toks|, which is ultimately saved into
% |\ID@fixedparams|.  If it finds a |#|, then wraps the whole thing into
% a group, since it's apparently safe regardless of whether the argument
% is delimited or not.
%    \begin{macrocode}
\def\ID@fixparams{%
  \begingroup
    \ID@toks{}%
    \futurelet\token\ID@fixparams@start
}
\def\ID@fixparams@start{%
  % (a) end of parameter list
  \ifx\token\ID@END\ID@then
    \ID@fixparams@end
  \fi
  % (b) parameter
  \ifcat\noexpand\token##\ID@then
    \ID@fixparams@param
  \fi
  % (c) space needs to be preserved
  \ifcat\noexpand\token\space\ID@then
    % This is copied from \ID@space
    \ID@toks\@xa\@xa\@xa{\@xa\the\@xa\ID@toks\space}%
    \@xa\futurelet\@xa\token\@xa\ID@fixparams@start\ID@unspace}%
  \fi
  % (d) default
  \iftrue\ID@then
    \ID@fixparams@normal
  \fi
  \ID@esac
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@fixparams@normal,\ID@fixparams@param,\ID@fixparams@end}
% These are the two commands that |\ID@fixparams| calls to actually
% consume each token, depending on whether it was a parameter.
%    \begin{macrocode}
\def\ID@fixparams@normal#1{%
  \ID@toks\@xa{\the\ID@toks#1}\futurelet\token\ID@fixparams@start
}
\def\ID@fixparams@param#1#2{%
  \def\@temp{\ID@toks\@xa{\the\ID@toks{#########2}}}\@temp
  \futurelet\token\ID@fixparams@start
}
\newcommand*\ID@fixparams@end[1]{%
  \@xa\endgroup\@xa\def\@xa\ID@fixedparams\@xa{\the\ID@toks}%
}
%    \end{macrocode}
% This should deal with everything \emph{except} a single |#|,
% but that's a hairy situation in the first place and we really don't
% want to allow using |\Super| in that case.  We could probably make
% an error message to say so.  The only other alternative would be to
% ``go back in time'' and change the last |{#1}| to a |#1{}| and even
% then we end up with an extra |{}| on the input stream.  I can't actually
% figure out how to test if this has happened in |...@insertp|, anyway.
% \end{macros}


  % was \ID@define


%
% \begin{macros}{\ID@scan,\ID@switch}
% This is the main loop.  We look at each token in turn and deal with it,
% mostly by inserting it into |\ID@toks|.  If it's a |\ID@END| then we're done.
% If it's |\Super| or |\Expand| then we need to do something special.
% If it's a space, then we need to add the space to
% |\ID@toks|.  Finally, if it's a |\bgroup| then we need to figure out whether
% it's an explicit or an implicit group.  In the former case, we descend into
% it (writing |{...}| to |\ID@toks|) and in the latter, we just pick it up like
% normal.
%    \begin{macrocode}
\newcommand\ID@scan{\futurelet\@foo\ID@switch}
\newcommand\ID@switch{%
  \let\next\ID@normal
  \ifx\@foo\ID@END
    \let\next\@gobble
  \fi
  \ifx\@foo\ID@super % macro name... what to do?
    \ifID@star
      \ifID@starstar
        \let\next\ID@expandmacro
      \else
        \let\next\ID@expandsuper
      \fi
    \fi
  \fi
  \ifx\@foo\Super
    \let\next\ID@expandsuper
  \fi
  \ifx\@foo\Expand
    \let\next\ID@expandnext
  \fi
  \ifx\@foo\UnsafeExpand
    \let\next\ID@expandunsafe
  \fi
  \ifx\@foo\MultiExpand
    \let\next\ID@expandmulti
  \fi
  \ifx\@foo\NoExpand
    \let\next\ID@noexpandnext
  \fi
  \ifx\@foo\Recurse
    \def\next{\@xa\@xa\@xa\ID@scan\@xa\@xa\@xa\NoExpand\@xa\@macroname\@gobble}%
  \fi
  \ifcat\noexpand\@foo\space
    \let\next\ID@space
  \fi
  \ifcat\noexpand\@foo\bgroup
    \let\next\ID@trygroup
  \fi
  \next
}
%    \end{macrocode}
% \end{macros}
% \begin{macros}{\ID@space,\ID@unspace}
% It's a bit tricky to deal with spaces properly.  In particular,
% picking up just a space from the token list takes some doing.  We
% need a fully-expandable macro so that the whole thing disappears.
% |\ID@space| then adds a space to |\ID@toks| and then expands
% |\ID@unspace| after |\ID@scan| so that the |\futurelet| sees the
% next token after the space and can deal with it properly.
% We need the |\expandafter| in defining |\ID@unspace| to actually get the
% space token into the parameter text; otherwise, it gets
% gobbled up by the lexer after reading the control sequence name.
%    \begin{macrocode}
\newcommand\ID@space{%
  \ID@toks\@xa\@xa\@xa{\@xa\the\@xa\ID@toks\space}%
  \@xa\ID@scan\ID@unspace
}
\newcommand\ID@unspace{}
\@xa\def\@xa\ID@unspace\space{}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@trygroup,\ID@recurse}
% The next two macros are used to check if the |\bgroup| token was an
% explicit or an implicit grouping character.  If it's explicit then
% the next macro that takes an argument will scoop the whole thing up
% at once, and so we need to be aware of this to deal with it.
% |\ID@trygroup| uses the special |#| delimiter and compares the argument
% with |\@empty| to see if anything comes before the next |{}|.  If it
% doesn't find anything then it was an explicit group and we recurse.
% One consequence of this is that we always need to put a |{}| after
% |\ID@END| so that we don't get an error here.
%    \begin{macrocode}
\newcommand\ID@trygroup{}
\long\def\ID@trygroup#1#{% check for explicit/implicit grouping!
  \def\@reservedd{#1}%
  \@xa\let\@xa\next
    \ifx\@reservedd\@empty\ID@recurse\else\ID@normal\fi
  \next#1%
}
%    \end{macrocode}
% Here we need to do some gymnastics to get the |{| and |}| tokens into
% the toks register.  It would be easiest if we could just add them one
% at a time, but we can only add \emph{balanced text}, so we need to
% expand the whole thing \emph{first} and then add it back to the register
% we expanded it into.  Thus, we enter a new level of grouping to save
% the contents of |\ID@toks|, expand the inner group, and use |\expandafter|
% across an |\endgroup| to get the correct tokens in the right place in
% |\ID@toks|.
%    \begin{macrocode}
\newcommand\ID@recurse[1]{%
  \begingroup\ID@toks{}% start a new level of grouping and empty \ID@toks
  \ID@scan#1\ID@END{}% % parse...
  \@xa\endgroup\@xa    % this fiasco should get the job done...!
  \ID@toks\@xa\@xa\@xa{\@xa\the\@xa\ID@toks\@xa{\the\ID@toks}}%
  \ID@scan
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@normal,ID@noexpandnext}
% This is what we do when it's not anything special.
%    \begin{macrocode}
\newcommand\ID@normal[1]{\ID@toks\@xa{\the\ID@toks#1}\ID@scan}
\newcommand\ID@noexpandnext[2]{\ID@toks\@xa{\the\ID@toks#2}\ID@scan}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@checkusage,\ID@checkredef}
% Here we define tests that will issue errors if the parameter
% texts aren't the same, or the original function isn't defined.
%    \begin{macrocode}
\newcommand*\ID@checkusage{%
  % Make sure parameter lists are the same, does nothing if undefined
  \ifx\@reserveda\@reservedb
  \else
    % Error messages
    \ifx\@reserveda\undefined % undefined - okay
    \else
      \global\ID@abortedtrue
      \ifx\@foo\Super
        \PackageError{inlinedef}{Cannot use \protect\Super\space in \expandafter
          \protect\@macroname\space because\MessageBreak
          parameter lists don't match:\MessageBreak
          `\@reservedb' (new) != `\@reserveda' (old)}\@eha
      \else
        \ifID@bang % auto-expansion forbidden
          \PackageError{inlinedef}{Cannot use \protect\Inline* auto-expansion in
            \expandafter\protect\@macroname\MessageBreak
            because parameter lists don't match:\MessageBreak
            `\@reservedb' (new) != `\@reserveda' (old)}\@eha
        \else
          \PackageError{inlinedef}{Parameter lists for
            \expandafter\protect\@macroname\space don't match:\MessageBreak
            `\@reservedb' (new) != `\@reserveda' (old)\MessageBreak
            Use !-form of \protect\Inline\space to ignore this}\@eha
        \fi
      \fi
    \fi
  \fi
}
\newcommand*\ID@checkredef{%
  \ifx\@reserveda\undefined % undefined - okay
    \PackageError{inlinedef}{Cannot use \ifx\@foo\Super\protect\Super\space
      \else\protect\Inline** \fi in \expandafter\protect\@macroname\space
      because \MessageBreak it hasn't been defined yet}%
      \@eha
    \global\ID@abortedtrue
  \fi
}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@expandsuper,\ID@expandnext,\ID@expandmulti,%
%                \ID@expandunsafe,\ID@expandmacro}
% These correspond to the two special tokens, |\Super| and |\Expand|.
% The first one tests that the parameter list is alright and that the
% original command wasn't undefined.  If all is well, it expands everything
% in the right order.  The second one is simpler, just inserting an
% |\expandafter| before the continuation (|\ID@scan|) to expand whatever
% comes next once.  There is (yet) no way to fully-expand, although several
% |\Expand|s and |\expandafter|s can be stacked cleverly to expand several
% things in a specific order.
%    \begin{macrocode}
\newcommand*\ID@expandsuper[1]{%
  \ID@checkusage\ID@checkredef
  \ifID@aborted\else
    \ID@toks\@xa\@xa\@xa\@xa\@xa\@xa\@xa
      {\@xa\@xa\@xa\the\@xa\@xa\@xa\ID@toks\@xa\ID@super\ID@fixedparams}%
  \fi
  \ID@scan
}



\def\DefineInlineCommand#1#2#{\ID@defineinline#1{#2}}
\def\ID@defineinline#1#2#3{%
  \@xa\def\@xa\@temp\@xa{\csname ID@\string#1\endcsname}%
  \@xa\ifx\@temp\relax\else\PackageError{inlinedef}{redefinition}\fi
  \@xa\def\csname ID@\string#1\endcsname#2{\begingroup#3\ID@END}%
  \@xa\def\@xa\ID@quarks\@xa{\ID@quarks#1}%
}


\NewInlineExpansion\ExpandIf[3][debug]{\IFELSE{#1}{#2}{#3}}
\Inline\def\foo{blah\ExpandIf[someotherflag]{abc}{def}blee}

 % => \newcommand{\ID@\ExpandIf}[3][debug]{\Continue{\IFELSE{#1}{#2}{#3}}}


\def\NewInlineExpansion#1{\begingroup\@ID@new{F}{#1}}
\def\RenewInlineExpansion#1{\begingroup\@ID@new{T}{#1}}
\def\ProvideInlineExpansion#1{\begingroup\@ID@new{}{#1}}
\def\@ID@new#1#2#3#{\@@ID@new{#1}{#2}{#3}}
\def\@@ID@new#1#2#3#4{
  \ID@checkdefined{#1}{#2}%
  \@xa\newcommand\csname ID@\string#2\endcsname#3{%
    \begingroup\Continue{#4}\C#END}}



\DefineInlineCommand\NoExpand#1{\Save{#1}}


\DefineInlineCommand\Super{%
  \ID@checkusage\ID@checkredef{Super}%
  \ifID@aborted\else
    \@xa\@xa\@xa\Save\@xa\@xa\@xa{\@xa\ID@super\ID@fixedparams}%
}


\newcommand\ID@expandnext[2]{%
  \ID@toks\@xa\@xa\@xa{\@xa\the\@xa\ID@toks#2}\ID@scan
}

\DefineInlineCommand\Expand#1{%
  \@xa\Save\@xa{#1}%
}


\newcommand\ID@expandmulti[3]{%
  \begingroup % #1 is the \MultiExpand...
    \ID@count#2\relax % this will need to be allocated too!
    \ID@toks{#3}%
    \@testtrue\ifnum\ID@count<\@ne\@testfalse\fi
    \@whilesw\if@test\fi{%
      \ID@toks\@xa\@xa\@xa{\the\ID@toks}% one expansion...
      \advance\ID@count\m@ne\ifnum\ID@count<\@ne\@testfalse\fi
    }%
  % The 1st \@xa expands the 2nd \the\ID@toks
  \@xa\endgroup
  % The 2nd \@xa starts after the \endgroup and expands the 1st \the\ID@toks
  \@xa\ID@toks\@xa\@xa\@xa
      {\@xa\the\@xa\ID@toks\the\ID@toks}%
  \ID@scan
}

\DefineInlineCommand\ExpandMulti#1#2{%
  \ifnum#1>\@ne
  \count@#1\relax
  \advance#1\m@ne
  % 1st \@xa: expand the first token of #2, 2nd \@xa: expand \the\count@
  \@xa\@xa\@xa\Continue
  \@xa\@xa\@xa{\@xa\@xa\@xa\ExpandMulti
    \@xa\@xa\@xa{\@xa\the\@xa\count@\@xa}\@xa{#2}}%
}

\DefineInlineCommand\ExpandFully#1{\edef\@temp{#1}\@xa\Save\@xa{\@temp}}

\DefineInlineCommand\ExpandUnsafe{\expandafter}


\InlineSpecial\def\ExpandFully#1{...}
\InlineSpecial\newcommand\foo[2][1]

\InlineExpand\def\ExpandIfT#1#2{...}

\Inline\newcommand... - could this work?


\def\ID@expandunsafe#1{\expandafter\ID@scan}
\def\ID@expandmacro#1{\expandafter\ID@scan\ID@super}
%    \end{macrocode}
% \end{macros}
%
% \begin{macros}{\ID@getprefix}
% This is used to compare argument lists.
%    \begin{macrocode}
\long\def\ID@getprefix#1:#2->#3\ID@END{\detokenize{#2}}
%    \end{macrocode}
% \end{macros}
%
% Finally we clean up by restoring |@|'s catcode.
%    \begin{macrocode}
\makeatother
%</package>
%    \end{macrocode}
%
% \StopIndexing
% \filbreak
% \section{Test suite}
% We include a somewhat-comprehensive test suite to make sure that everything
% is working.  If it works properly, it should output nothing.
%
% First we define a few helper-functions to test for errors, etc.
%    \begin{macrocode}
%<*testsuite>
\documentclass{minimal}
\usepackage{inlinedef}
\makeatletter
\errorcontextlines=10
\def\WantError#1#2#3{%
  \let\WE@packageerror\PackageError
  \def\PackageError##1##2##3{%
    \protected@edef\@goterror{##2}\protected@edef\@wanterror{#2}%
    \edef\@goterror{\@xa\detokenize\@xa{\@goterror}}%
    \edef\@wanterror{\@xa\detokenize\@xa{\@wanterror}}%
    \protected@edef\@gotpackage{##1}\protected@edef\@wantpackage{#1}%
    \edef\@gotpackage{\@xa\detokenize\@xa{\@gotpackage}}%
    \edef\@wantpackage{\@xa\detokenize\@xa{\@wantpackage}}%
    \global\let\PackageError\WE@packageerror
    \@tempswafalse
    \ifx\@gotpackage\@wantpackage\else\message{^^J(arg 1 differs)^^J}\@tempswatrue\fi
    \ifx\@goterror\@wanterror\else\message{^^J(arg 2 differs)^^J}\@tempswatrue\fi
    \ifx#3##3\else\message{^^J(arg 3 differs)^^J}\@tempswatrue\fi
    \if@tempswa\PackageError{inlinedef (test)}{wrong error}\@eha\PackageError{##1}{##2}##3\fi
  }%
}

\def\CheckError{%
  \ifx\PackageError\WE@packageerror\else
    \PackageError{inlinedef (test)}{expected error not thrown}\@eha\fi
  \global\let\PackageError\WE@packageerror
}
\newcommand\CheckDefinition[1][]{\@CheckDefinition{#1}}
\def\@CheckDefinition#1#2#3#{\@checkdefn{#1}#2{#3}}
\def\@checkdefn#1#2#3#4{#1\def\@reserveda#3{#4}\ifx#2\@reserveda\else
  \message{^^J^^J\meaning#2^^J(got)vs(wanted)^^J\meaning\@reserveda^^J^^J}
  \PackageError{inlinedef (test)}{definition of \detokenize{#2}didn't match}\@eha\fi
}
\let\eha\@eha\let\ehd\@ehd
\makeatother
%    \end{macrocode}
%
% Here we predefine copies of the errors so that we can look for them easily
%    \begin{macrocode}
\catcode`\#=12
\def\pound{#}
\catcode`\#=6

\def\WantSuperNoMatch#1#2#3{%
  \WantError{inlinedef}{Cannot use \protect\Super\space in 
    \protect#1\space because\MessageBreak
    parameter lists don't match:\MessageBreak
    `#3' (new) != `#2' (old)}\eha
}
\def\WantStarNoMatch#1#2#3{%
  \WantError{inlinedef}{Cannot use \protect\Inline* auto-expansion in
    \protect#1\MessageBreak because
    parameter lists don't match:\MessageBreak
    `#3' (new) != `#2' (old)}\eha
}
\def\WantNoMatchBang#1#2#3{%
\WantError{inlinedef}{Parameter lists for
  \protect#1\space don't match:\MessageBreak
  `#3' (new) != `#2' (old)\MessageBreak
  Use !-form of \protect\Inline\space to ignore this}\eha
}
\def\WantOnlyDefGdef{%
  \WantError{inlinedef}{Only \protect\def\space and \protect\gdef\space are
    allowed after \protect\Inline,\MessageBreak but some other type of
    definition was found}\eha
}
\def\WantNoDefGdef{%
  \WantError{inlinedef}{No \protect\def\space or \protect\gdef\space found
    after \protect\Inline}\ehd
}
\def\WantSuperNoRedef#1{%
  \WantError{inlinedef}{Cannot use \protect\Super\space in \protect#1\space
    because \MessageBreak it hasn't been defined yet}\eha
}
%    \end{macrocode}
%
% Now we start the actual tests.
%    \begin{macrocode}
 % I. Basic stuff
 %    A. Simple definition
\let\a\undefined
\Inline\def\a{b}
\CheckDefinition\a{b}

 %    B. Simple redefinition
\def\a{b}
\Inline\def\a{d}
\CheckDefinition\a{d}

 %    C. Erroneous redefinition (needs !)
\def\a{b}
\WantNoMatchBang\a{}{\pound1}
\Inline\def\a#1{c}
\CheckError
\CheckDefinition\a{b} % shouldn't have changed

\def\a{b}
\Inline!\def\a#1{c}
\CheckDefinition\a#1{c}

 %    D. Local/global definition
\def\a{b}
\begingroup
\Inline\def\a{c}
\endgroup
\CheckDefinition\a{b}

\begingroup
\Inline\gdef\a{c}
\endgroup
\CheckDefinition\a{c}

{\Inline\global\def\a{d}}
\CheckDefinition\a{d}

 %    E. Collecting arguments
\Inline\long\def\a{e}
\CheckDefinition[\long]\a{e}

\Inline\outer\def\a{f}
\edef\a{\meaning\a}
\edef\b{\detokenize{\outer macro:->f}}
\@xa\CheckDefinition\@xa\a\@xa{\b}

\Inline\long\outer\def\a{g}
\edef\a{\meaning\a}
\edef\b{\string\long\string\outer\space\detokenize{macro:->g}}
\@xa\CheckDefinition\@xa\a\@xa{\b}

\def\a{g}
\Inline!\long\def\a#1{h}
\CheckDefinition[\long]\a#1{h}

 % II. Special tokens
 %    A. Recursion
\def\a{b}
\Inline\def\a{a\a c}
\CheckDefinition\a{a\a c}

 %    B. Expansion
\def\a{b}
\Inline\def\a{a\Expand\a c}
\CheckDefinition\a{abc}

\def\a{b}
\Inline\def\a{\Expand a\Expand\a\Expand c}
\CheckDefinition\a{abc}

\def\a{\b}
\def\b{c}
\Inline\def\a{a\Expand\a c}
\CheckDefinition\a{a\b c}

\toks0{b}\toks1{d}
\Inline\def\a{a\the\toks0c\the\toks1e}
\CheckDefinition\a{a\the\toks0c\the\toks1e}

\Inline\def\a{a\Expand{\the\toks0}c\Expand{\the\toks1}e}
\CheckDefinition\a{abcde}

\Inline\def\a{\Expand{a\the\toks0}c\Expand{\the\toks1}e}
\CheckDefinition\a{a\the\toks0cde}

\Inline\def\a{\Expand{\expandafter a\the\toks0}c\Expand{\the\toks1e}}
\CheckDefinition\a{abcde}

\NewInlineCommand\ExpandIf#1#2{
  
}

 %       i. Tricky expansions
 %\def\x{\ifflag}
 %\edef\xx{\expandafter\string\x}
 %\show\xx
 %%% idea: \Expand\iffoo
 %%%   - use same trick as \newif (i.e. \@xa\def\@if#1{true}{...}
 %%%     where \@if#1#2 -> \csname\@xa\if@\string#1#2\endcsname.
 %%%           \if@ if -> .
 %%%   - optionally remove the if (or maybe use futurelets to pick off
 %%%     one at a time -> \ID@is@an@if#1
 %%%   - if so then evaluate the if in a controlled setting, then
 %%%     gather everything into token register until we find a BALANCED
 %%%     \else and/or \fi.  The balanced part is tricky... and then we
 %%%     end up with weird behavior because the \fi is already gobbled
 %%%     when it wouldn't normally be, so attempts to \@xa it will be
 %%%     surprising.
 %%% instead:
 %%%   \ExpandIf{foo}{...}?\Else{...}?
 %%%   \ExpandIf{foo}{...}?\Else{...}?
 %%%   \ExpandIf\foo{...}?\Else{...}?


\newif\ifflag
\Inline\def\a{a\MultiExpand2{\ifflag b\else c\fi}d}
\CheckDefinition\a{acd}
\flagtrue
 %\Inline\def\a{a\Expand{\ifflag b\else c\fi}d}
 %\CheckDefinition\a{abd}

 %    C. MultiExpand
\def\x{\y}
\def\y{\z}
\def\z{0}
\Inline\def\a{a\MultiExpand0\x b}
\CheckDefinition\a{a\x b}

\Inline\def\a{a\MultiExpand1\x b}
\CheckDefinition\a{a\y b}

\Inline\def\a{a\MultiExpand2\x b}
\CheckDefinition\a{a\z b}

\Inline\def\a{a\MultiExpand3\x b}
\CheckDefinition\a{a0b}

\Inline\def\a{a\MultiExpand{10}\x b}
\CheckDefinition\a{a0b}

 %      i. use with \expandafter
\Inline\def\a{a\MultiExpand2{\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a\y\y b}

\Inline\def\a{a\MultiExpand1{\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a\expandafter\y\x b}

\Inline\def\a{a\MultiExpand2{\expandafter\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a\x\z b}

\Inline\def\a{a\MultiExpand3{\expandafter\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a\y\z b}

\Inline\def\a{a\MultiExpand4{\expandafter\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a\z\z b}

\Inline\def\a{a\MultiExpand5{\expandafter\expandafter\expandafter\x\x}b}
\CheckDefinition\a{a0\z b}

 %    D. UnsafeExpand
\def\x{b\Super c}
\Inline\def\a{a\Expand\x d}
\CheckDefinition\a{ab\Super cd}

\def\a{0}
\Inline\def\a{a\UnsafeExpand\x d}
\CheckDefinition\a{ab0cd}

\def\a{b\Super d}
\Inline\def\a{a\UnsafeExpand\a e}
\CheckDefinition\a{abb\Super dde}

\def\a{b\Super d}
\Inline**\def\a{a\a e}
\CheckDefinition\a{abb\Super dde}

  % Would be nice if we could catch TeX capacity exceeded errors...
  % Then try \def\a{b\a d}\Inline**\def\a{a\a e}

\def\x#1{b#1d}
\Inline\def\a{a\x ce}
\CheckDefinition\a{a\x ce}

\Inline\def\a{a\UnsafeExpand\x ce}
\CheckDefinition\a{abcde}

 %    E. NoExpand
\Inline\def\a{a\NoExpand\Expand\x b}
\CheckDefinition\a{a\Expand\x b}

\Inline*\def\a{a\NoExpand\a b}
\CheckDefinition\a{a\a b}

\Inline**\def\a{a\NoExpand\a b}
\CheckDefinition\a{a\a b}

\Inline\def\a{a\NoExpand{\Expand\x\Expand\y}b}
\CheckDefinition\a{a\Expand\x\Expand\y b}

 %    F. Super
\def\a{bcd}
\Inline\def\a{a\Super e}
\CheckDefinition\a{abcde}

\def\a#1{b#1d}
\Inline\def\a#1{a\Super e}
\CheckDefinition\a#1{ab#1de}

\def\a#1{b#1d}
\Inline*\def\a#1{a\Super e}
\CheckDefinition\a#1{ab#1de}

\def\a#1{b#1d}
\Inline**\def\a#1{a\Super e}
\CheckDefinition\a#1{ab#1de}

 %    G. Recurse
\def\a{q}
\Inline\def\a{a\Recurse b}
\CheckDefinition\a{a\a b}

\Inline*\def\a{a\Recurse b}
\CheckDefinition\a{a\a b}

\Inline**\def\a{a\Recurse b}
\CheckDefinition\a{a\a b}

 % III. Tricky parsing
 %    A. Spaces
\def\a{b c d}
\Inline\def\a{a \Super e}
\CheckDefinition\a{a b c de}

\def\a{b  c d}
\Inline\def\a{a \Expand\a e}
\CheckDefinition\a{a b c de}

\def\a{b  c d}
\Inline\def\a{a \Expand{\a} e}
\CheckDefinition\a{a b c d e}

\Inline\def\a{a\NoExpand{\Expand\x\Expand\y} b}
\@xa\CheckDefinition\@xa\a\@xa{\@xa a\@xa\Expand\@xa\x\@xa\Expand\@xa\y\space b}

 %    B. Grouping
\def\a{b{c d}e}
\Inline\def\a{{a\Super}f\Super}
\CheckDefinition\a{{ab{c d}e}fb{c d}e}

\Inline\def\a{{ }{}}
\Inline\def\a{{\Expand\a\a}{} {{\Super}{}}}
\CheckDefinition\a{{{ }{}\a}{} {{{ }{}}{}}}

 %    C. Parameters
\def\a#1bcd#2{[#1...#2]}
\Inline\def\a#1bcd#2{a\Super b}
\CheckDefinition\a#1bcd#2{a[#1...#2]b}

\iffalse -- this infinite loops
   -- to fix, need to \ensurefixedparams and then add {\ID@XXX} at end (always?)
   -- can't distinguish \bgroup from {\bgroup}, but shouldn't matter...
   -- actually we can, with #1#
   -- but we do need to worry about wrapping the last delimited arg before a #!
   -- so we really do need to be careful about that

   -- would be nice to just not fill in the params, though this
   -- makes it a little harder to expand...
   -- would be nice to have an \ExpandAfter
   -- TODO - replace quarks with sets --> better scoping?
           - just use the special's name as-is... - already needs a \detokenize?

   -- add a quick KI check for  #1{->#2{#3\END against  \meaning#1{->{x\END
      or something like that - what if meaning has a { in it already? etc
        -- will need to temporarily change { catcode
        -- how to get last token in list?!? delimit -> and see if last is {
           reverse token list is not too hard...
http://tex.stackexchange.com/questions/36034/most-efficient-way-to-reverse-a-token-list-tail-recursion



\def\a#1bcd#2#{[#1...#2]}
\Inline\def\a#1bcd#2#{a\Super b}
\CheckDefinition\a#1bcd#2{a[#1...#2]b}
\fi

\def\a#1\##2{y}
\Inline\def\a#1\##2{x\UnsafeExpand\a{#1}\#{#2}z}
\CheckDefinition\a#1\##2{xyz}

\def\a#1\##2{#1y#2}
\Inline\def\a#1\##2{x\UnsafeExpand\a{#1}\#{#2}z}
\CheckDefinition\a#1\##2{x#1y#2z}

 %      i. spaces!
\def\a #1 {y}
\Inline\def\a#1 {x\Super z}
\CheckDefinition\a#1 {xyz}

\@xa\def\@xa\a\space{y}
\@xa\Inline\@xa\def\@xa\a\space{x\Super z}
\@xa\CheckDefinition\@xa\a\space{xyz}

 %      ii. funky catcodes
 %%%% This test fails.
 %\begingroup
 %  \catcode`&=6
 %  \def\a&1{b#1d}
 %  \Inline\def\a#1{a\Super e}
 %  \CheckDefinition\a#1{b&1d}
 %\endgroup

 %    D. Active characters
\begingroup
  \catcode`A=13
  \defA#1{b#1d}
  \Inline\defA#1{aAe}
  \CheckDefinitionA#1{aAe}

  \defA#1{b#1d}
  \Inline*\defA#1{aAe}
  \CheckDefinitionA#1{ab#1de}
\endgroup

 % IV. Auto-expansion

\def\a#1{y}
\Inline\def\a#1{x\a z}
\CheckDefinition\a#1{x\a z}

\def\a#1{y}
\Inline*\def\a#1{x\a z}
\CheckDefinition\a#1{xyz}

\def\a#1{y}
\Inline**\def\a#1{x\a{#1}z}
\CheckDefinition\a#1{xyz}

 %    A. With delimited arguments
\def\a[#1]#2{#1y#2}
\Inline*\def\a[#1]#2{x\a z}
\CheckDefinition\a[#1]#2{x#1y#2z}

\def\a[#1]#2{#1y#2}
\Inline**\def\a[#1]#2{x\a[#1]{#2}z}
\CheckDefinition\a[#1]#2{x#1y#2z}

 % V. Errors

\def\bar#1{d #1 f}
\def\x{b}

\WantSuperNoMatch\a{\pound1}{.\pound1}
\def\a#1{x}
\Inline!\def\a.#1{y\Super}
\CheckError
\CheckDefinition\a#1{x}

\WantStarNoMatch\a{\pound1}{.\pound1}
\def\a#1{x}
\Inline*!\def\a.#1{y\a}
\CheckError
\CheckDefinition\a#1{x}

\def\a#1{x}
\Inline!\def\a.#1{y} % ok
\CheckDefinition\a.#1{y}

\WantOnlyDefGdef
\def\foo{a}
\Inline\edef\foo{b}
\CheckError
\CheckDefinition\foo{a}
\let\foo\undefined

\WantOnlyDefGdef
\Inline\global\outer\xdef{}
\CheckError

\WantOnlyDefGdef
\Inline\global\outer\abc\space vbcda s \newcommand{}
\CheckError

\WantNoDefGdef
\Inline\let\relax\relax
\CheckError

\WantNoDefGdef
\Inline{}
\CheckError

\WantSuperNoRedef\foo
\Inline\def\foo#1{a \Expand\x\space cd #1 fg \x\space i\Super}
\CheckError

\WantNoMatchBang\a{}{\pound1}
\def\a{b}
\Inline\def\a#1{a\a c}
\CheckError

 % Miscellaneous (read: "old") tests

\def\test#1{d #1 f}
\Inline\def\test#1{a \Expand\x\space c\Super g \x\space i}
\CheckDefinition\test#1{a b\space cd #1 fg \x\space i}

\Inline*\def\bar#1{a \Expand\x\space c\bar g \x\space i}
\CheckDefinition\bar#1{a b\space cd #1 fg \x\space i}

\def\bar#1{d #1 f}
\Inline**\def\bar#1{a \Expand\x\space c\bar{#1}g \x\space i}
\CheckDefinition\bar#1{a b\space cd #1 fg \x\space i}

\Inline\def\foo#1{a \Expand\x\space cd #1 fg \x\space i}
\CheckDefinition\foo#1{a b\space cd #1 fg \x\space i}

\def\a{b}
\Inline!\def\a#1{a\Expand\a c}
\CheckDefinition\a#1{abc}

\def\a{b}
\Inline!**\def\a#1{a\a c}
\CheckDefinition\a#1{abc}

\Inline\def\a#1{a\a c}
\CheckDefinition\a#1{a\a c}

\Inline\def\a#1{a\Recurse c}
\CheckDefinition\a#1{a\a c}

\Inline!\def\a{a\NoExpand{b\Super c}d}
\CheckDefinition\a{ab\Super cd}

\Inline*\def\a{gh\a jk}
\CheckDefinition\a{ghab\Super cdjk}

 % SURPRISE!  unsafe expansion...
\def\a{ab\Super cd}
\Inline**\def\a{gh\a jk}
\CheckDefinition\a{ghabab\Super cdcdjk}

\def\a{ab\Super cd}
\Inline\def\a{gh\UnsafeExpand\a jk}
\CheckDefinition\a{ghabab\Super cdcdjk}

\def\x{\x a} % This is a fun one...!
\Inline\def\a{\MultiExpand{5}\x}
\CheckDefinition\a{\x aaaaa}

\message{^^JAll tests completed.^^J}

\begin{document}
\end{document}
%</testsuite>
%    \end{macrocode}
%
% \makeatother
% \eject
% \Finale
%
%
% \iffalse
%
% The next line of code prevents DocStrip from adding the
% character table to the generated files(s).

% Removed stuff

\endinput
%
% \fi
%
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%%




 %%%%% TODO - do we need this?

 %% \ifx\detokenize\ID@UNDEFINED
 %%   \def\ID@empty#1{%
 %%     \begingroup\def\@temp{#1}\expandafter\endgroup
 %%     \csname @\ifx\@temp\@empty first\else second\fi oftwo\endcsname
 %%   }
 %% \else
 %%   % eTeX version using detokenize
 %%   \def\ID@empty#1{%
 %%     \csname @\if\relax\detokenize#1\relax first\else second\fi oftwo\endcsname
 %%   }
 %% \fi
